use aes::Aes256;
use anyhow::{Context, Result};
use cbc::cipher::{block_padding::Pkcs7, BlockEncryptMut, KeyIvInit};
use digest::Digest;
use serde::Deserialize;
use sha1::Sha1;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

#[derive(Deserialize, Debug)]
pub struct Config {
    pub user: User,
    pub headers: HashMap<String, String>,
}

#[derive(Deserialize, Debug)]
pub struct User {
    pub account: String,
    pub encrypted_password: String,
}

const DEFAULT_CONFIG_TEMPLATE: &str = r#"# SchedulEase Configuration File

# --- Request Headers ---
# General headers to mimic a real browser.
# You may modify them to your own browser's headers if needed.
[headers]
User-Agent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
Accept = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"
Accept-Language = "en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7"
DNT = "1"
Connection = "keep-alive"
Upgrade-Insecure-Requests = "1"
Sec-Fetch-Dest = "document"
Sec-Fetch-Mode = "navigate"
Sec-Fetch-Site = "none"
Sec-Fetch-User = "?1"
Cache-Control = "max-age=0"
Sec-Ch-Ua = '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"'
Sec-Ch-Ua-Mobile = "?0"
Sec-Ch-Ua-Platform = '"macOS"'

# --- User Credentials ---
# University portal username and password below.
# Actual password will not be recorded for safety. 
# DO NOT share this file with others.
[user]
account = "{account}"
encrypted_password = "{encrypted_password}"
"#;

fn get_config_path() -> Result<PathBuf> {
    #[cfg(debug_assertions)]
    {
        // In debug mode, use the path relative to the project root.
        Ok(PathBuf::from("rust/data/config.toml"))
    }
    #[cfg(not(debug_assertions))]
    {
        let mut path = std::env::current_exe().context("Failed to get current executable path")?;
        path.pop(); // Remove the executable's filename.
        path.push("config.toml");
        Ok(path)
    }
}

pub fn load_config() -> Result<Config> {
    let config_path = get_config_path()?;
    let contents = fs::read_to_string(&config_path)
        .with_context(|| format!("Failed to read config file at {:?}", config_path))?;
    let config: Config = toml::from_str(&contents)?;
    Ok(config)
}

pub fn create_config(account: &str, password: &str) -> Result<()> {
    let config_path = get_config_path()?;

    if let Some(parent) = config_path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory at {:?}", parent))?;
    }

    let encrypted_password = encrypt(password);
    // They are not real string templates, however `replace` here is more than enough
    // to replace the placeholders with actual values.
    let config_content = DEFAULT_CONFIG_TEMPLATE
        .replace("{account}", account)
        .replace("{encrypted_password}", &encrypted_password);

    fs::write(&config_path, config_content)
        .with_context(|| format!("Failed to write config file to {:?}", config_path))?;

    // println!("Default configuration file created at {:?}", config_path);
    Ok(())
}

/// Encryption algorithm adapted from source code, generated by AI
pub fn encrypt(password: &str) -> String {
    const MAX_SAFE_INT: &[u8] = b"9007199254740991";

    // Generate key from MD5 hash of MAX_SAFE_INT
    let key_hex = hex::encode(md5::compute(MAX_SAFE_INT).as_slice());

    // Generate IV from SHA1 hash of the key
    let mut sha1_hasher = Sha1::new();
    sha1_hasher.update(key_hex.as_bytes());
    let iv_hex = hex::encode(sha1_hasher.finalize());

    // Create cipher with key and IV (truncated to required lengths)
    let cipher = cbc::Encryptor::<Aes256>::new_from_slices(
        &key_hex.as_bytes()[..32], // AES-256 key (32 bytes)
        &iv_hex.as_bytes()[..16],  // AES IV (16 bytes)
    )
    .expect("Failed to create AES cipher: Invalid key or IV length");

    // Prepare buffer for encryption with padding
    let plaintext = password.as_bytes();
    let buffer_size = (plaintext.len() / 16 + 1) * 16;
    let mut buffer = vec![0u8; buffer_size];
    buffer[..plaintext.len()].copy_from_slice(plaintext);

    // Encrypt with PKCS#7 padding and return as hex string
    let ciphertext = cipher
        .encrypt_padded_mut::<Pkcs7>(&mut buffer, plaintext.len())
        .expect("Failed to encrypt password");

    hex::encode(ciphertext)
}
